// Copyright (c) 2015, the Fletch project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE.md file.

// Should become auto-generated.

library todomvc_presenter_model;

import 'todomvc_service.dart';

/*
  The presentation model should be generated by a terse description.
  For example, the presenter model for this sample might have been declared as:

  struct Immutable {
    union {
      Atom;
      Cons;
    }
  }

  struct Atom {
    union {
      Nil;
      Bool bool;
      Str str;
    }
  }

  struct Cons {
    Immutable fst;
    Immutable snd;
  }

  service TodoListPresenter {
    void Create(Str);
    void Delete(Int32);
    void Complete(Int32);
    void Clear();
  }

  From the description we would generate dart classes and their path descriptors
  for each struct together with the diff algorithm. For services we would create
  command descriptors. All of these would come with serialization support for
  wire transfer.

  Until then, all of the above is implemented below.

 */

// Tracing to ease debugging on fletch...
bool TRACE = false;
void trace(obj) { if (TRACE) print("  $obj"); }

// Some constants.

const TAG_CONS_FST = 0;
const TAG_CONS_SND = 1;

// Immutable model for the presentation (reused as a mutable mirror on the
// "host" side).  (just sexp to simulate a "rich structure" for now)

abstract class Immutable {
  void diff(Immutable other, Path path, MyPatchSet patches);
  void serialize(NodeBuilder builder);
}

abstract class Atom extends Immutable {
  final value;
  Atom(this.value);
  String toString() => "value($value)";

  void diff(Immutable other, Path path, MyPatchSet patches) {
    trace("Atom::diff $this ~=~ $other");
    if (other is Atom && value == other.value)
      return;
    patches.add(path, this);
  }
}

class Cons extends Immutable {
  final Immutable fst, snd;
  Cons(this.fst, this.snd);
  String toString() => "($fst . $snd)";

  void diff(Immutable other, Path path, MyPatchSet patches) {
    if (other is Cons) {
      fst.diff(other.fst, new ConsFst(path), patches);
      snd.diff(other.snd, new ConsSnd(path), patches);
      return;
    }
    patches.add(path, this);
  }

  void serialize(NodeBuilder builder) {
    trace("Cons::serialize: $this");
    ConsBuilder cons = builder.initCons();
    fst.serialize(cons.initFst());
    snd.serialize(cons.initSnd());
  }
}

class Nil extends Atom {
  Nil() : super(null);
  void serialize(NodeBuilder builder) {
    trace("Nil::serialize");
    builder.setNil();
  }
}

class Bool extends Atom {
  Bool(bool value) : super(value);
  void serialize(NodeBuilder builder) {
    trace("Bool::serialize: $this");
    builder.bool = value;
  }
}

class Num extends Atom {
  Num(num value) : super(value);
  void serialize(NodeBuilder builder) {
    trace("Num::serialize: $this");
    builder.num = value;
  }
}

class Str extends Atom {
  Str(String value) : super(value);
  void serialize(NodeBuilder builder) {
    trace("Str::serialize: $this");
    encodeStr(value, builder.initStr());
  }

  static void encodeStr(String s, StrBuilder builder) {
    int length = s.length;
    List<int> chars = builder.initChars(length);
    for (var i = 0; i < length; ++i) {
      chars[i] = s.codeUnitAt(i);
    }
  }
}


// Path in the immutable model. (We probably won't need an actual representation
// of these. We could just construct the serialized form on the fly).

// Note that (serialize) reverses the path description. Ie, we construct the
// path 'inside-out' and read it 'outside-in' on the host side.

abstract class Path {
  final Path parent;
  Path(this.parent);
  int get tag;

  static void serialize(Path inner, PatchBuilder builder) {
    trace("Path::serialize: path($inner)");
    int length = 0;
    for (Path current = inner; current != null; current = current.parent) {
      ++length;
    }
    var out = builder.initPath(length);
    for (Path current = inner; current != null; current = current.parent) {
      out[--length] = current.tag;
    }
  }

  String toString() => "$parent;$tag";
}

class ConsFst extends Path {
  ConsFst(Path parent) : super(parent);
  int get tag => TAG_CONS_FST;
}

class ConsSnd extends Path {
  ConsSnd(Path parent) : super(parent);
  int get tag => TAG_CONS_SND;
}

// Patch description

class MyPatchSet {
  List<Patch> patches = new List<Patch>();
  add(Path path, Immutable content) => patches.add(new Patch(path, content));

  void serialize(PatchSetBuilder builder) {
    var length = patches.length;
    trace("MyPatchSet::serialize: length($length)");
    var out = builder.initPatches(patches.length);
    for (int i = 0; i < length; ++i) {
      patches[i].serialize(out[i]);
    }
  }
}

class Patch {
  Path path;
  Immutable content;
  Patch(this.path, this.content);

  void serialize(PatchBuilder builder) {
    trace("Patch::serialize");
    Path.serialize(path, builder);
    content.serialize(builder.initContent());
  }
}
