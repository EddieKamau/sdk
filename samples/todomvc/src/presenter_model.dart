// Copyright (c) 2015, the Fletch project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE.md file.

library todomvc.presenter_model;

import 'dart:typed_data';

/*
  The presentation model should be generated by a terse description.
  For example, the presenter model for this sample might have been declared as:

  struct Immutable {
    union {
      Atom;
      Cons;
    }
  }

  struct Atom {
    union {
      Nil;
      Bool bool;
      Str str;
    }
  }

  struct Cons {
    Immutable fst;
    Immutable snd;
  }

  service TodoListPresenter {
    void Create(Str);
    void Delete(Int32);
    void Complete(Int32);
    void Clear();
  }

  From the description we would generate dart classes and their path descriptors
  for each struct together with the diff algorithm. For services we would create
  command descriptors. All of these would come with serialization support for
  wire transfer.

  Until then, all of the above is implemented below.

 */

// Tracing to ease debugging on fletch...
bool TRACE = true;
void trace(obj, [flag = true]) {
  if (!TRACE || flag == false || flag == null)
    return;
  print("  $obj");
}

// Some constants.

final ENDIAN = Endianness.LITTLE_ENDIAN;

const TAG_NIL = 0;
const TAG_TRUE = 1;
const TAG_FALSE = 2;
const TAG_NUM = 3;
const TAG_STR = 4;
const TAG_CONS = 5;

const TAG_CONS_FST = 0;
const TAG_CONS_SND = 1;

const TAG_CREATE = 0;
const TAG_DELETE = 1;
const TAG_COMPLETE = 2;
const TAG_CLEAR = 3;

// Serialization helpers.
int setUint8(ByteData data, int offset, int value) {
  if (data != null) data.setUint8(offset, value);
  return 1;
}
int setUint32(ByteData data, int offset, int value) {
  if (data != null) data.setUint32(offset, value, ENDIAN);
  return 4;
}
int setInt32(ByteData data, int offset, int value) {
  if (data != null) data.setInt32(offset, value, ENDIAN);
  return 4;
}

int getUint8(data, [offset = 0]) => data.getUint8(offset);
int getUint32(data, [offset = 0]) => data.getUint32(offset, ENDIAN);
int getInt32(data, [offset = 0]) => data.getInt32(offset, ENDIAN);


// Immutable model for the presentation (reused as a mutable mirror on the
// "host" side).  (just sexp to simulate a "rich structure" for now)

abstract class Immutable {
  void diff(Immutable other, Path path, PatchSet patches);

  int serialize(ByteData data, int offset);

  static Result deserialize(ByteData data, int offset) {
    int tag = getUint8(data, offset++);
    trace("Immutable::deserialize: offset(${offset-1}), tag($tag)");
    switch (tag) {
      case TAG_NIL:   return new Result(new Nil(), offset);
      case TAG_TRUE:  return new Result(new Bool(true), offset);
      case TAG_FALSE: return new Result(new Bool(false), offset);
      case TAG_NUM:   return Num.deserialize(data, offset);
      case TAG_STR:   return Str.deserialize(data, offset);
      case TAG_CONS:  return Cons.deserialize(data, offset);
      default: throw new Exception("Invalid tag $tag");
    }
  }
}

abstract class Atom extends Immutable {
  /*final*/ var value;
  Atom(this.value);
  String toString() => "value($value)";

  void diff(Immutable other, Path path, PatchSet patches) {
    trace("Atom::diff $this ~=~ $other");
    if (other is Atom && value == other.value)
      return;
    patches.add(path, this);
  }
}

class Cons extends Immutable {
  /*final*/ Immutable fst, snd;
  Cons(this.fst, this.snd);
  int get tag => TAG_CONS;
  String toString() => "($fst . $snd)";

  void diff(Immutable other, Path path, PatchSet patches) {
    trace("Cons::diff $this ~=~ $other");
    if (other is Cons) {
      fst.diff(other.fst, new ConsFst(path), patches);
      snd.diff(other.snd, new ConsSnd(path), patches);
      return;
    }
    patches.add(path, this);
  }

  int serialize(ByteData data, int offset) {
    trace("Cons::serialize: offset($offset)", data);
    int next = offset;
    next += setUint8(data, next, tag);
    next += fst.serialize(data, next);
    next += snd.serialize(data, next);
    return next - offset;
  }

  static Result deserialize(ByteData data, int offset) {
    trace("Cons::deserialize: offset($offset)", data);
    Result res1 = Immutable.deserialize(data, offset);
    Result res2 = Immutable.deserialize(data, res1.offset);
    return new Result(new Cons(res1.result, res2.result), res2.offset);
  }
}

class Nil extends Atom {
  Nil() : super(null);
  int get tag => TAG_NIL;
  int serialize(ByteData data, int offset) {
    trace("Nil::serialize: offset($offset)", data);
    return setUint8(data, offset, tag);
  }
}

class Bool extends Atom {
  Bool(bool value) : super(value);
  int get tag => value ? TAG_TRUE : TAG_FALSE;
  int serialize(ByteData data, int offset) {
    trace("Bool::serialize: offset($offset), value($value)", data);
    return setUint8(data, offset, tag);
  }
}

class Num extends Atom {
  Num(num value) : super(value);
  int get tag => TAG_NUM;
  int serialize(ByteData data, int offset) {
    setUint8(data, offset, tag);
    setInt32(data, offset + 1, value);
    trace("Num::serialize: offset($offset), value($value)", data);
    return 5;
  }
  static Result deserialize(ByteData data, int offset) {
    int value = getInt32(data, offset);
    trace("Num::deserialize: offset($offset), value($value)");
    return new Result(new Num(value), offset + 4);
  }
}

class Str extends Atom {
  Str(String value) : super(value);
  int get tag => TAG_STR;
  int serialize(ByteData data, int offset) {
    trace("Str::serialize: offset($offset), value($value)", data);
    int next = offset;
    next += setUint8(data, next, tag);
    next += setUint32(data, next, value.length);
    for (var i = 0; i < value.length; ++i) {
      next += setUint8(data, next, value.codeUnitAt(i));
    }
    return next - offset;
  }
  static Result deserialize(ByteData data, int offset) {
    int length = getUint32(data, offset);
    offset += 4;
    var view = new Uint8List.view(data.buffer, offset, length);
    var value = new String.fromCharCodes(view);
    trace("Str::deserialize: offset(${offset-4}), value($value)");
    return new Result(new Str(value), offset + length);
  }
}


// Commands that can be issued by the host.
// The 'apply' methods should be defined via the 'Presenter' implementation.

abstract class Command {
  int serialize(ByteData data, int offset);
  static Result deserialize(ByteData data, int offset) {
    int tag = getUint8(data, offset++);
    trace("Command::deserialize: offset($offset), tag($tag)");
    switch (tag) {
      case TAG_CREATE: return CreateCommand.deserialize(data, offset);
      case TAG_DELETE: return DeleteCommand.deserialize(data, offset);
      case TAG_COMPLETE: return CompleteCommand.deserialize(data, offset);
      case TAG_CLEAR: return ClearCommand.deserialize(data, offset);
      default: throw new Exception("Invalid command tag $tag");
    }
  }
}

class CreateCommand extends Command {
  Str title;
  CreateCommand(this.title);
  int get tag => TAG_CREATE;
  int serialize(ByteData data, int offset) {
    trace("CreateCommand::serialize: offset($offset)", data);
    int next = offset;
    next += setUint8(data, next, tag);
    next += title.serialize(data, next);
    return next - offset;
  }
  static Result deserialize(ByteData data, int offset) {
    trace("CreateCommand::deserialize: offset($offset)");
    int strTag = getUint8(data, offset++);
    assert(strTag == TAG_STR);
    Result strRes = Str.deserialize(data, offset);
    return new Result(new CreateCommand(strRes.result), strRes.offset);
  }
}

class DeleteCommand extends Command {
  int id;
  DeleteCommand(this.id);
  int get tag => TAG_DELETE;
  int serialize(ByteData data, int offset) {
    trace("DeleteCommand::serialize: offset($offset)", data);
    int next = offset;
    next += setUint8(data, next, tag);
    next += setUint8(data, next, id);
    return next - offset;
  }
  static Result deserialize(ByteData data, int offset) {
    trace("DeleteCommand::deserialize: offset($offset)");
    int id = getUint8(data, offset++);
    return new Result(new DeleteCommand(id), offset);
  }
}

class CompleteCommand extends Command {
  int id;
  CompleteCommand(this.id);
  int get tag => TAG_COMPLETE;
  int serialize(ByteData data, int offset) {
    trace("CompleteCommand::serialize: offset($offset)", data);
    int next = offset;
    next += setUint8(data, next, tag);
    next += setUint8(data, next, id);
    return next - offset;
  }
  static Result deserialize(ByteData data, int offset) {
    trace("CompleteCommand::deserialize: offset($offset)");
    int id = getUint8(data, offset++);
    return new Result(new CompleteCommand(id), offset);
  }
}

class ClearCommand extends Command {
  ClearCommand();
  int get tag => TAG_CLEAR;
  int serialize(ByteData data, int offset) {
    trace("ClearCommand::serialize: offset($offset)", data);
    return setUint8(data, offset, tag);
  }
  static Result deserialize(ByteData data, int offset) {
    trace("ClearCommand::deserialize: offset($offset)");
    return new Result(new ClearCommand(), offset);
  }
}

// Path in the immutable model. (We probably won't need an actual representation
// of these. We could just construct the serialized form on the fly).

// Note that (deserialize `compose` serialize) reverses the path description
// which is what we want. Ie, we construct the path 'inside-out' and read it
// 'outside-in' on the host side.

abstract class Path {
  Path parent;
  Path(this.parent);
  int get tag;
  static int serialize(Path path, ByteData data, int offset) {
    trace("Path::serialize: offset($offset), path($path)", data);
    int next = offset + 4;
    while (path != null) {
      setUint8(data, next++, path.tag);
      path = path.parent;
    }
    int bytes = next - offset;
    setUint32(data, offset, bytes - 4);
    return bytes;
  }
  static Result deserialize(ByteData data, int offset) {
    int init = offset;
    int length = getUint32(data, offset);
    offset += 4;
    Path path = null;
    int end = offset + length;
    while (offset < end) {
      int tag = getUint8(data, offset++);
      switch (tag) {
        case TAG_CONS_FST: path = new ConsFst(path); break;
        case TAG_CONS_SND: path = new ConsSnd(path); break;
        default: throw new Exception("Invalid path tag $tag");
      }
    }
    trace("Path::deserialize: offset($init), path($path)");
    return new Result(path, offset);
  }

  String toString() => "$tag;$parent";
}

class ConsFst extends Path {
  ConsFst(Path p) : super(p);
  int get tag => TAG_CONS_FST;
}

class ConsSnd extends Path {
  ConsSnd(Path p) : super(p);
  int get tag => TAG_CONS_SND;
}

// Patch description

class PatchSet {
  List<Patch> patches = new List<Patch>();
  add(Path path, Immutable content) => patches.add(new Patch(path, content));

  static PatchSet deserialize(ByteData data, int bytes) {
    int offset = 0;
    PatchSet patches = new PatchSet();
    while (offset < bytes) {
      Result res = Patch.deserialize(data, offset);
      patches.patches.add(res.result);
      offset = res.offset;
    }
    assert(offset == bytes);
    return patches;
  }
}

class Patch {
  Path path;
  Immutable content;
  Patch(this.path, this.content);
  int serialize(ByteData data, int offset) {
    trace("Patch::serialize: offset($offset)", data);
    int pathSize = Path.serialize(path, data, offset);
    int contentSize = content.serialize(data, offset + pathSize);
    return pathSize + contentSize;
  }

  static Result deserialize(ByteData data, int offset) {
    trace("Patch::deserialize: offset($offset)");
    Result pathRes = Path.deserialize(data, offset);
    Result contentRes = Immutable.deserialize(data, pathRes.offset);
    return new Result(new Patch(pathRes.result, contentRes.result),
                      contentRes.offset);
  }
}

// Deserialization result pair.
class Result {
  var result;
  int offset;
  Result(this.result, this.offset);
}

ByteData serializeList(List xs) {
  // Reserve space for size header
  int offset = 4;
  // Calculate payload space
  int bytes = 0;
  for (var x in xs) {
    bytes += x.serialize(null, offset);
  }
  var data = new ByteData(bytes + offset);
  setUint32(data, 0, bytes);
  for (var x in xs) {
    offset += x.serialize(data, offset);
  }
  return data;
}
